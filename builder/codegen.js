const c = require('compact-encoding')
const gen = require('generate-object-property')
const s = require('generate-string')
const p = require('path')
const pkg = require('../package.json')

const COLLECTION_TYPE = 0

const IndexTypeMap = new Map([
  ['uint', 'IndexEncoder.UINT'],
  ['uint8', 'IndexEncoder.UINT'],
  ['uint16', 'IndexEncoder.UINT'],
  ['uint24', 'IndexEncoder.UINT'],
  ['uint32', 'IndexEncoder.UINT'],
  ['uint40', 'IndexEncoder.UINT'],
  ['uint48', 'IndexEncoder.UINT'],
  ['uint56', 'IndexEncoder.UINT'],
  ['uint64', 'IndexEncoder.UINT'],
  ['string', 'IndexEncoder.STRING'],
  ['utf8', 'IndexEncoder.STRING'],
  ['ascii', 'IndexEncoder.STRING'],
  ['hex', 'IndexEncoder.STRING'],
  ['base64', 'IndexEncoder.STRING'],
  ['fixed32', 'IndexEncoder.BUFFER'],
  ['fixed64', 'IndexEncoder.BUFFER'],
  ['buffer', 'IndexEncoder.BUFFER'],
  ['bool', 'IndexEncoder.BOOL']
])

const Falsies = new Map([
  ['uint', '0'],
  ['uint8', '0'],
  ['uint16', '0'],
  ['uint24', '0'],
  ['uint32', '0'],
  ['uint40', '0'],
  ['uint48', '0'],
  ['uint56', '0'],
  ['uint64', '0'],
  ['string', "''"],
  ['utf8', "''"],
  ['ascii', "''"],
  ['hex', "''"],
  ['base64', "''"]
])

module.exports = function generateCode(hyperdb, { directory = '.', esm = false } = {}) {
  let str = ''
  str += '// This file is autogenerated by the hyperdb compiler\n'
  str += '/* eslint-disable camelcase */\n'
  str += '\n'
  if (esm) {
    str += `import { IndexEncoder, c, b4a } from '${pkg.name}/runtime'\n`
    str += "import { version, getEncoding, setVersion } from './messages.js'\n"
    str += '\n'
  } else {
    str += `const { IndexEncoder, c, b4a } = require('${pkg.name}/runtime')\n`
    str += "const { version, getEncoding, setVersion } = require('./messages.js')\n"
    str += '\n'
  }

  str += `const versions = { schema: version, db: ${hyperdb.version} }\n\n`

  let addedHelper = false
  for (const ns of hyperdb.namespaces.values()) {
    if (!ns.helpers) continue
    addedHelper = true
    const helpers = p.relative(p.resolve(directory), ns.helpers).replaceAll('\\', '/')
    if (esm) {
      str += `import * as helpers${ns.id} from '${helpers}'\n`
    } else {
      str += `const helpers${ns.id} = require('${helpers}')\n`
    }
  }
  if (addedHelper) str += '\n'

  const collections = []
  const indexes = []

  for (let i = 0; i < hyperdb.orderedTypes.length; i++) {
    const type = hyperdb.orderedTypes[i]
    if (type.isCollection) {
      collections.push(type)
      str += generateCollectionDefinition(type)
    } else if (type.isIndex) {
      indexes.push(type)
      str += generateIndexDefinition(type)
    }
    str += '\n'
  }

  str += 'const collections = [\n'
  for (let i = 0; i < collections.length; i++) {
    str += `  ${getId(collections[i]) + (i < collections.length - 1 ? ',' : '')}\n`
  }
  str += ']\n\n'
  str += 'const indexes = [\n'
  const lines = []
  for (let i = 0; i < indexes.length; i++) {
    if (indexes[i].deprecated) continue
    lines.push(`  ${getId(indexes[i])}`)
  }
  str += lines.join(',\n') + (lines.length ? '\n' : '')
  str += ']\n\n'

  if (esm) {
    str += 'export default { versions, collections, indexes, resolveCollection, resolveIndex }\n'
  } else {
    str += 'module.exports = { versions, collections, indexes, resolveCollection, resolveIndex }\n'
  }

  str += '\n'

  str += 'function resolveCollection (name) {\n'
  str += '  switch (name) {\n'
  for (let i = 0; i < collections.length; i++) {
    const type = collections[i]
    str += `    case ${s(type.fqn)}: return ${getId(type)}\n`
  }
  str += '    default: return null\n'
  str += '  }\n'
  str += '}\n'
  str += '\n'

  str += 'function resolveIndex (name) {\n'
  str += '  switch (name) {\n'
  for (let i = 0; i < indexes.length; i++) {
    const type = indexes[i]
    str += `    case ${s(type.fqn)}: return ${getId(type)}\n`
  }
  str += '    default: return null\n'
  str += '  }\n'
  str += '}\n'

  return str
}

function generateCommonPrefix(type) {
  const id = type.isCollection ? getId(type) : getId(type)

  let str = ''

  str += `// ${s(type.fqn)} collection key\n`
  str += `const ${id}_key = ${generateIndexKeyEncoding(type)}\n`
  str += '\n'

  if (type.isMapped) {
    str += `// ${s(type.fqn)} has the following schema defined key map\n`
    str += `const ${id}_map = ${gen('helpers' + type.getNamespace().id, type.map)}\n`
    str += '\n'
  }

  str += `function ${id}_indexify (record) {\n`

  // mapped types can only support ranges in the map space when non-unique
  const len = type.isMapped ? type.indexKey.length : type.fullKey.length

  if (len === 0) {
    str += '  return []\n'
  } else if (len === 1) {
    str += `  const a = ${getKeyPath(type.fullKey[0], 'record', true)}\n`
    str += '  return a === undefined ? [] : [a]\n'
  } else {
    str += '  const arr = []\n'
    str += '\n'

    for (let i = 0; i < len; i++) {
      const key = type.fullKey[i]
      str += `  const a${i} = ${getKeyPath(key, 'record', true)}\n`
      str += `  if (a${i} === undefined) return arr\n`
      str += `  arr.push(a${i})\n`
      str += '\n'
    }
    str += '  return arr\n'
  }

  str += '}\n'
  str += '\n'

  return str
}

function generateCollectionDefinition(collection) {
  const id = getId(collection)

  const versionedUserland = !!collection.versionField
  const versioned = collection.version > 0 && !versionedUserland

  let str = generateCommonPrefix(collection)

  str += `// ${s(collection.fqn)} value encoding\n`
  str += `const ${id}_enc = getEncoding(${s(collection.valueEncoding)})\n`
  str += '\n'

  if (collection.trigger) {
    str += `// ${s(collection.fqn)} has the following schema defined trigger\n`
    str += `const ${id}_trigger = ${gen('helpers' + collection.getNamespace().id, collection.trigger)}\n`
    str += '\n'
  }

  str += `// ${s(collection.fqn)} reconstruction function\n`
  str += `function ${id}_reconstruct (schemaVersion, keyBuf, valueBuf) {\n`
  if (collection.key.length) str += `  const key = ${id}_key.decode(keyBuf)\n`
  str += '  setVersion(schemaVersion)\n'
  str += '  const state = { start: 0, end: valueBuf.byteLength, buffer: valueBuf }\n'

  if (versioned) {
    str += '  const type = c.uint.decode(state)\n'
    str += `  if (type !== ${COLLECTION_TYPE}) throw new Error('Unknown collection type: ' + type)\n`
    str += `  ${id}.decodedVersion = c.uint.decode(state)\n`
  }

  str += `  const record = ${id}_enc.decode(state)\n`

  for (let i = 0; i < collection.key.length; i++) {
    const key = collection.key[i]
    str += `  ${getKeyPath(key, 'record', false)} = key[${i}]\n`
  }

  if (versionedUserland) {
    str += `  ${id}.decodedVersion = ${gen('record', collection.versionField)}\n`
  }

  str += '  return record\n'
  str += '}\n'

  str += `// ${s(collection.fqn)} key reconstruction function\n`
  str += `function ${id}_reconstruct_key (keyBuf) {\n`
  if (collection.key.length) str += `  const key = ${id}_key.decode(keyBuf)\n`

  str += generateKeyReconstruct('  ', collection.key, 'key') + '\n'
  str += '}\n'

  str += '\n'
  str += `// ${s(collection.fqn)}\n`
  str += `const ${id} = {\n`
  str += `  name: ${s(collection.fqn)},\n`
  str += `  id: ${collection.id},\n`
  str += `  version: ${collection.version},\n`
  str += generateEncodeCollectionKey(collection, ',')
  str += generateEncodeKeyRange(collection, ',')
  str += generateEncodeCollectionValue(collection, ',')
  str += `  trigger: ${collection.trigger ? id + '_trigger' : 'null'},\n`
  str += `  reconstruct: ${id}_reconstruct,\n`
  str += `  reconstructKey: ${id}_reconstruct_key,\n`
  str += '  indexes: [],\n'
  str += '  decodedVersion: 0\n'
  str += '}\n'
  return str
}

function generateIndexDefinition(index) {
  const id = getId(index)
  const collectionId = getId(index.collection)
  const offset = index.deprecated ? '-1' : `${collectionId}.indexes.length`

  let str = generateCommonPrefix(index)
  str += `// ${s(index.fqn)}\n`
  str += `const ${id} = {\n`
  str += `  name: ${s(index.fqn)},\n`
  str += `  version: ${index.version},\n`
  str += `  id: ${index.id},\n`
  str += generateEncodeIndexKey(index, ',')
  str += generateEncodeKeyRange(index, ',')
  str += `  encodeValue: (record) => ${id}.collection.encodeKey(record),\n`
  str += generateEncodeIndexKeys(index, ',')
  str += '  reconstruct: (keyBuf, valueBuf) => valueBuf,\n'
  str += `  offset: ${offset},\n`
  str += `  collection: ${collectionId}\n`
  str += '}\n'

  if (!index.deprecated) {
    str += `${collectionId}.indexes.push(${id})\n`
  }

  return str
}

function generateEncodeKeyRange(index, sep) {
  const id = getId(index)
  const falsy = Falsies.get(index.key.type)
  const c = (n) => (falsy ? `(${n} || ${n} === ${falsy})` : n)

  let str = ''
  str += '  encodeKeyRange ({ gt, lt, gte, lte } = {}) {\n'
  str += `    return ${id + '_key'}.encodeRange({\n`
  str += `      gt: ${c('gt')} ? ${id}_indexify(gt) : null,\n`
  str += `      lt: ${c('lt')} ? ${id}_indexify(lt) : null,\n`
  str += `      gte: ${c('gte')} ? ${id}_indexify(gte) : null,\n`
  str += `      lte: ${c('lte')} ? ${id}_indexify(lte) : null\n`
  str += '    })\n'
  str += `  }${sep}\n`
  return str
}

function generateEncodeCollectionValue(collection, sep) {
  const id = getId(collection)
  const versionedUserland = !!collection.versionField
  const versioned = collection.version > 0 && !versionedUserland
  const maxEnd = versioned ? getUintLength(collection.version) + 1 : 0

  let str = ''
  str += '  encodeValue (schemaVersion, collectionVersion, record) {\n'
  str += '    setVersion(schemaVersion)\n'
  str += `    const state = { start: 0, end: ${maxEnd}, buffer: null }\n`

  if (versionedUserland) {
    str += `${gen('record', collection.versionField)} = collectionVersion\n`
  }

  str += `    ${id}_enc.preencode(state, record)\n`
  str += '    state.buffer = b4a.allocUnsafe(state.end)\n'

  if (versioned) {
    str += `    state.buffer[state.start++] = ${COLLECTION_TYPE}\n`

    // collectionVersion is always <= collection.version so lets see if we can optimise
    if (getUintLength(collection.version) === 1) {
      str += '    state.buffer[state.start++] = collectionVersion\n'
    } else {
      str += '    c.uint.encode(state, collectionVersion)\n'
    }
  }

  str += `    ${id}_enc.encode(state, record)\n`

  if (versioned && getUintLength(collection.version) > 1) {
    // we might have over allocated if the runtime version is low - dbl check
    str += '    return state.buffer.subarray(0, state.start)\n'
  } else {
    str += '    return state.buffer\n'
  }

  str += `  }${sep}\n`
  return str
}

function generateEncodeCollectionKey(collection, sep) {
  const id = getId(collection)

  const accessors = toProps('record', collection.fullKey)
  let str = ''
  str += '  encodeKey (record) {\n'
  str += `    const key = [${accessors.join(', ')}]\n`
  str += `    return ${id + '_key'}.encode(key)\n`
  str += `  }${sep}\n`
  return str
}

function generateEncodeIndexKeys(index, sep) {
  const id = getId(index)

  let str = ''
  str += '  encodeIndexKeys (record, context) {\n'
  if (index.isMapped) {
    const indexAccessors = toProps('mappedRecord', index.indexKey)
    const recordAccessors = toProps('record', index.fullKey.slice(index.indexKey.length))
    const accessors = indexAccessors.concat(recordAccessors)
    str += `    const mapped = ${id}_map(record, context)\n`
    str += '    const keys = new Array(mapped.length)\n'
    str += '    for (let i = 0; i < mapped.length; i++) {\n'
    str += '      const mappedRecord = mapped[i]\n'
    str += `      keys[i] = ${id + '_key'}.encode([${accessors.join(', ')}])\n`
    str += '    }\n'
    str += '    return keys\n'
  } else {
    const accessors = toProps('record', index.fullKey)
    str += `    return [${id + '_key'}.encode([${accessors.join(', ')}])]\n`
  }
  str += `  }${sep}\n`
  return str
}

function generateEncodeIndexKey(index, sep) {
  const id = getId(index)

  let str = ''
  str += '  encodeKey (record) {\n'
  str += `    return ${id}_key.encode(${id}_indexify(record))\n`
  str += `  }${sep}\n`
  return str
}

function toProps(name, keys) {
  return keys.map((c) => (c === null ? name : c.split('.').reduce(gen, name)))
}

function generateKeyReconstruct(indent, keys, key) {
  if (keys.length === 0) return indent + 'return {}'

  const grouped = new Map()

  for (let index = 0; index < keys.length; index++) {
    const k = keys[index].split('.')
    let map = grouped

    for (let i = 0; i < k.length; i++) {
      let info = map.get(k[i])

      if (!info) {
        info = { key: null, index: -1, map: null }
        map.set(k[i], info)
      }

      if (i === k.length - 1) {
        info.key = keys[index]
        info.index = index
      } else {
        map = info.map = new Map()
      }
    }
  }

  return indent + 'return ' + generate(indent, grouped)

  function generate(indent, map) {
    let s = '{\n'
    const all = [...map]
    for (let i = 0; i < all.length; i++) {
      const [k, v] = all[i]
      s += indent + `  ${gen.property(k)}: `
      if (v.index !== -1) {
        s += `${key}[${v.index}]`
      } else {
        s += generate(indent + '  ', v.map)
      }
      s += i === all.length - 1 ? '\n' : ',\n'
    }
    s += indent + '}'
    return s
  }
}

function generateIndexKeyEncoding(type) {
  let str = 'new IndexEncoder([\n'
  for (let i = 0; i < type.keyEncoding.length; i++) {
    const component = type.keyEncoding[i]

    const keyType = type.builder.schema.types.get(`@${type.namespace}/${component}`)

    if (keyType?.isArray) str += '  c.array('

    if (keyType?.isEnum) str += '  IndexEncoder.UINT'
    else if (keyType?.isArray) str += IndexTypeMap.get(keyType.type.fqn)
    else str += '  ' + IndexTypeMap.get(component)

    if (keyType?.isArray) str += ')'

    if (i !== type.keyEncoding.length - 1) str += ',\n'
    else str += '\n'
  }
  str += `], { prefix: ${type.id} })`
  return str
}

function getId(type) {
  return type.isCollection ? getCollectionId(type) : getIndexId(type)
}

function getCollectionId(collection) {
  return 'collection' + collection.id
}

function getIndexId(index) {
  return 'index' + index.id
}

function getKeyPath(key, name, optional) {
  if (key === null) return name
  const r = (a, b, i) => (i === 0 || !optional ? gen(a, b) : gen.optional(a, b))
  return key.split('.').reduce(r, name)
}

function getUintLength(n) {
  const state = { buffer: null, start: 0, end: 0 }
  c.uint.preencode(state, n)
  return state.end
}
