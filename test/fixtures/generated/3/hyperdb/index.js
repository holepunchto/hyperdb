// This file is autogenerated by the hyperdb compiler
/* eslint-disable camelcase */

const { IndexEncoder, c } = require('@holepunchto/hyperdb/runtime')

const { version, resolveStruct } = require('./messages.js')

// '@db/digest' collection key
const collection0_key = new IndexEncoder([
  IndexEncoder.NONE
], { prefix: 0 })

function collection0_indexify (record) {
  const a = record.key
  return a === undefined ? [] : [a]
}

// '@db/digest' reconstruction function
function collection0_reconstruct (version, keyBuf, valueBuf) {
  const key = collection0_key.decode(keyBuf)
  const value = c.decode(resolveStruct('@db/digest/value', version), valueBuf)
  // TODO: This should be fully code generated
  return {
    key: key[0],
    ...value
  }
}

// '@db/digest'
const collection0 = {
  name: '@db/digest',
  id: 0,
  stats: false,
  encodeKey (record = {}) {
    const key = [record.key]
    const encoded = collection0_key.encode(key)
    console.log('ENCODED HERE IS:', encoded)
    return encoded
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return collection0_key.encodeRange({
      gt: gt ? collection0_indexify(gt) : null,
      lt: lt ? collection0_indexify(lt) : null,
      gte: gte ? collection0_indexify(gte) : null,
      lte: lte ? collection0_indexify(lte) : null
    })
  },
  encodeValue (version, record) {
    return c.encode(resolveStruct('@db/digest/value', version), record)
  },
  trigger: null,
  reconstruct: collection0_reconstruct,
  indexes: []
}

// '@db/members' collection key
const collection1_key = new IndexEncoder([
  IndexEncoder.NONE,
  IndexEncoder.STRING
], { prefix: 1 })

function collection1_indexify (record) {
  const arr = []

  arr.push(null)

  const a1 = record.id
  if (a1 === undefined) return arr
  arr.push(a1)

  return arr
}

// '@db/members' reconstruction function
function collection1_reconstruct (version, keyBuf, valueBuf) {
  const key = collection1_key.decode(keyBuf)
  const value = c.decode(resolveStruct('@db/members/value', version), valueBuf)
  // TODO: This should be fully code generated
  return {
    key: key[0],
    id: key[1],
    ...value
  }
}

// '@db/members'
const collection1 = {
  name: '@db/members',
  id: 1,
  stats: true,
  encodeKey (record = {}) {
    const key = [record.key, record.id]
    return collection1_key.encode(key)
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return collection1_key.encodeRange({
      gt: gt ? collection1_indexify(gt) : null,
      lt: lt ? collection1_indexify(lt) : null,
      gte: gte ? collection1_indexify(gte) : null,
      lte: lte ? collection1_indexify(lte) : null
    })
  },
  encodeValue (version, record) {
    return c.encode(resolveStruct('@db/members/value', version), record)
  },
  trigger: null,
  reconstruct: collection1_reconstruct,
  indexes: []
}

// 'stats' collection key
const collection2_key = new IndexEncoder([
  IndexEncoder.UINT
], { prefix: 2 })

function collection2_indexify (record) {
  const a = record.id
  return a === undefined ? [] : [a]
}

// 'stats' reconstruction function
function collection2_reconstruct (version, keyBuf, valueBuf) {
  const key = collection2_key.decode(keyBuf)
  const value = c.decode(resolveStruct('stats/value', version), valueBuf)
  // TODO: This should be fully code generated
  return {
    id: key[0],
    ...value
  }
}

// 'stats'
const collection2 = {
  name: 'stats',
  id: 2,
  stats: false,
  encodeKey (record = {}) {
    const key = [record.id]
    return collection2_key.encode(key)
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return collection2_key.encodeRange({
      gt: gt ? collection2_indexify(gt) : null,
      lt: lt ? collection2_indexify(lt) : null,
      gte: gte ? collection2_indexify(gte) : null,
      lte: lte ? collection2_indexify(lte) : null
    })
  },
  encodeValue (version, record) {
    return c.encode(resolveStruct('stats/value', version), record)
  },
  trigger: null,
  reconstruct: collection2_reconstruct,
  indexes: []
}

// '@db/members-by-age' collection key
const index3_key = new IndexEncoder([
  IndexEncoder.NONE,
  IndexEncoder.UINT,
  IndexEncoder.NONE,
  IndexEncoder.STRING
], { prefix: 3 })

function index3_indexify (record) {
  const arr = []

  arr.push(null)

  const a1 = record.age
  if (a1 === undefined) return arr
  arr.push(a1)

  arr.push(null)

  const a3 = record.id
  if (a3 === undefined) return arr
  arr.push(a3)

  return arr
}

// '@db/members-by-age'
const index3 = {
  name: '@db/members-by-age',
  id: 3,
  stats: false,
  encodeKey (record) {
    return index3_key.encode(index3_indexify(record))
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return index3_key.encodeRange({
      gt: gt ? index3_indexify(gt) : null,
      lt: lt ? index3_indexify(lt) : null,
      gte: gte ? index3_indexify(gte) : null,
      lte: lte ? index3_indexify(lte) : null
    })
  },
  encodeValue: (doc) => index3.collection.encodeKey(doc),
  encodeIndexKeys (record, context) {
    return [index3_key.encode([record.key, record.age, record.key, record.id])]
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection1.indexes.length,
  collection: collection1
}
collection1.indexes.push(index3)

module.exports = {
  version,
  collections: [
    collection0,
    collection1,
    collection2
  ],
  indexes: [
    index3
  ],
  resolveCollection,
  resolveIndex
}

function resolveCollection (name) {
  switch (name) {
    case '@db/digest': return collection0
    case '@db/members': return collection1
    case 'stats': return collection2
    default: return null
  }
}

function resolveIndex (name) {
  switch (name) {
    case '@db/members-by-age': return index3
    default: return null
  }
}
