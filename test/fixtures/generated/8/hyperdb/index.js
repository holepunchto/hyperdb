// This file is autogenerated by the hyperdb compiler
/* eslint-disable camelcase */

const { IndexEncoder, c, b4a } = require('hyperdb/runtime')
const { version, getEncoding, setVersion } = require('./messages.js')

const versions = { schema: version, db: 1 }

// '@db/books' collection key
const collection0_key = new IndexEncoder([
  IndexEncoder.STRING,
  c.array(IndexEncoder.STRING)
], { prefix: 0 })

function collection0_indexify (record) {
  const arr = []

  const a0 = record.title
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.tags
  if (a1 === undefined) return arr
  arr.push(a1)

  return arr
}

// '@db/books' value encoding
const collection0_enc = getEncoding('@db/book/hyperdb#0')

// '@db/books' reconstruction function
function collection0_reconstruct (schemaVersion, keyBuf, valueBuf) {
  const key = collection0_key.decode(keyBuf)
  setVersion(schemaVersion)
  const state = { start: 0, end: valueBuf.byteLength, buffer: valueBuf }
  const type = c.uint.decode(state)
  if (type !== 0) throw new Error('Unknown collection type: ' + type)
  collection0.decodedVersion = c.uint.decode(state)
  const record = collection0_enc.decode(state)
  record.title = key[0]
  record.tags = key[1]
  return record
}
// '@db/books' key reconstruction function
function collection0_reconstruct_key (keyBuf) {
  const key = collection0_key.decode(keyBuf)
  return {
    title: key[0],
    tags: key[1]
  }
}

// '@db/books'
const collection0 = {
  name: '@db/books',
  id: 0,
  version: 1,
  encodeKey (record) {
    const key = [record.title, record.tags]
    return collection0_key.encode(key)
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return collection0_key.encodeRange({
      gt: gt ? collection0_indexify(gt) : null,
      lt: lt ? collection0_indexify(lt) : null,
      gte: gte ? collection0_indexify(gte) : null,
      lte: lte ? collection0_indexify(lte) : null
    })
  },
  encodeValue (schemaVersion, collectionVersion, record) {
    setVersion(schemaVersion)
    const state = { start: 0, end: 2, buffer: null }
    collection0_enc.preencode(state, record)
    state.buffer = b4a.allocUnsafe(state.end)
    state.buffer[state.start++] = 0
    state.buffer[state.start++] = collectionVersion
    collection0_enc.encode(state, record)
    return state.buffer
  },
  trigger: null,
  reconstruct: collection0_reconstruct,
  reconstructKey: collection0_reconstruct_key,
  indexes: [],
  decodedVersion: 0
}

// '@db/books-by-tag' collection key
const index1_key = new IndexEncoder([
  c.array(IndexEncoder.STRING),
  IndexEncoder.STRING,
  c.array(IndexEncoder.STRING)
], { prefix: 1 })

function index1_indexify (record) {
  const arr = []

  const a0 = record.tags
  if (a0 === undefined) return arr
  arr.push(a0)

  const a1 = record.title
  if (a1 === undefined) return arr
  arr.push(a1)

  const a2 = record.tags
  if (a2 === undefined) return arr
  arr.push(a2)

  return arr
}

// '@db/books-by-tag'
const index1 = {
  name: '@db/books-by-tag',
  version: 1,
  id: 1,
  encodeKey (record) {
    return index1_key.encode(index1_indexify(record))
  },
  encodeKeyRange ({ gt, lt, gte, lte } = {}) {
    return index1_key.encodeRange({
      gt: gt ? index1_indexify(gt) : null,
      lt: lt ? index1_indexify(lt) : null,
      gte: gte ? index1_indexify(gte) : null,
      lte: lte ? index1_indexify(lte) : null
    })
  },
  encodeValue: (record) => index1.collection.encodeKey(record),
  encodeIndexKeys (record, context) {
    return [index1_key.encode([record.tags, record.title, record.tags])]
  },
  reconstruct: (keyBuf, valueBuf) => valueBuf,
  offset: collection0.indexes.length,
  collection: collection0
}
collection0.indexes.push(index1)

const collections = [
  collection0
]

const indexes = [
  index1
]

module.exports = { versions, collections, indexes, resolveCollection, resolveIndex }

function resolveCollection (name) {
  switch (name) {
    case '@db/books': return collection0
    default: return null
  }
}

function resolveIndex (name) {
  switch (name) {
    case '@db/books-by-tag': return index1
    default: return null
  }
}
